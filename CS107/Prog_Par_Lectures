								LECTURE 2

How does representing numbers in Binary work?

It's really easy. Firstly, it is very obvious that 0 in an 8 bit binary will be 0000 0000. There is no question about that. Now a number like 7 in binary will be 0000 0111. So it is highly intuitive to represent any number >= 0.

But how to represent negative numbers? Well the only rule to follow is that the negative representation in binary when added to the equivalent positive representation in binary should always equal 0. 

So, how to represent -7 in binary?

Well, 7 -> 0000 0111. So what number will you add to this to get 0? None. If you add ANY number to this number, it will still be a positive number because there is no negative number identifier. If there is no identifier, every number be default is a positive integer. So first you need to decide on which bit will tell whether the number is positive or negative.

Let us mark the MSB as the sign identifier. So the maximum positive integer value for an 8 bit field is 127.

Now having defined the sign, how will you represent a negative number? Well it's easy isn't it? You take a positive number and change the MSB to 1. Well...let us try that.

Let us represent -7. According to your rule, -7 -> 1000 0111. Right? Yes. So the maximum negative number value for 8 bits is -127.

Okay so let us do a basic test to see whether this works. Let us add 7 and -7, and check if we get a 0.

0000 0111 + 1000 0111 => 1000 1110. Now does this number look like 0 to you? It looks more like -14. So our -7 representation is wrong. Not so easy isn't it?

Explain why such representation will need much more circuitry.

You know, just intuitively, if you have a positive number in binary, the negative of that, should be something like the +ve flipped over. So it should be like you're flipping the whole number and intuitively that should give you a -ve number.

Okay well, let us do something interesting. Let us not use the MSB for anything. Really? So now our range of +ve numbers is from 0 to 127. And for each positive number, there will be a corresponding -ve number which can be generated by flipping all bits from the +ve number. Let us call this process 1's complement.

Well, sounds interesting. So this is what the Set will look like - 

0000 0000 -> 0
1111 1111 -> -0
0000 0001 -> 1
1111 1110 -> -1
.
.
0111 1111 -> 127
1000 0000 -> -127

So the Max +ve number = 127
The Max -ve number = -127
And 0 has 2 representations.

Okay, now does this work? Let us test it.

64 + 64 = 128 i.e. Buffer Overflow. Unspecified result
0100 0000 + 0100 0000 => 1000 0000. Gives -127. Well that is okay.

64 + 63 = 127
0100 0000 + 0011 1111 => 0111 1111 => 127.

Nice.

Let us try +ve and -ve

-64 + 64
1011 1111 + 0100 0000 => 1111 1111 => -0. Nice.

-64 + 63
1011 1111 + 0011 1111 => 1111 1110 => -1. Wow.

-63 + 64
1100 0000 + 0100 0000 => 0000 0000 => 0 != 1. Inconsistent. Wrong.

-3 + 4
1111 1100 + 0000 0100 => 0000 0000 => 0 != 1. Wrong.

Seems like adding a smaller -ve number to a larger +ve number gives an off by 1 error. Adding 1 to this result gives the proper result.

So Rule -> If -ve < +ve, add 1 to result.

-5 + (-3)
1111 1010 + 1111 1100 => 1111 0110 => -9. Wrong.

So if you add -ve to -ve. Add 1 again.

Hence, this representation has 2 constraints in its algorithms - 

If -ve < +ve : Add 1
If both -ve  : Add 1

Why does this happen? Well, because there are 2 representations of 0 here. So when you add 2 numbers, and if the value rolls over going through 1111 1111 then you will be off by 1. Now this will only happen if you have 2 negative numbers, that will always result in a roll over OR a negative number lesser than a positive number, this will also result in a rollover. The below table will make it crystal clear - 

0000 0000 -> 0
0000 0001 -> 1
.
.
0111 1111 -> 127
1000 0000 -> -127
1000 0001 -> -126
.
.
1111 1110 -> -1
1111 1111 -> 0

Now any 2 numbers to be added, must roll over through 1111 1111 to get back to the -ve range. Any +ve < -ve is fine, because it will not roll over and it will stay in the -ve range. But a -ve < +ve means it has to roll over the 1111 1111 and hence an off by 1 again.

So 1's complement should be clear by now. As you can see, these constraints will demand a lot of additional circuitry, just because there are 2 representations of 0. We need some system where there is no such issue, and therefore will remove the need for additional complex circuitry.

So the first method needs a LOT of additonal circuitry because of LOT more constraints.
The 1's complment needs lesser additional circuitry because of less constraints.

Let us see if there is a representation with even lesser constraints.

							What does '=' do?

Apparently, '=' simply does a bit copy in most cases...Yes MOST cases! Not all.

So what does it mean? Um...if you use '=' to copy a larger bit pattern into a smaller one it will simply copy bit by bit and truncate whatever is left. But if you try the opposite, it will copy everything and then place 0 in the remaining bits....

So when does it NOT do this? Well if you use '=' to copy a negative number, either from a larger bit pattern to a smaller or vice versa, it CANNOT just simply copy the bit pattern. Because we also need to show copy the sign somehow. So the way this works is, if you are copying a smaller pattern into a bigger pattern, the MSB of smaller is replicated for all remaining bits in the bigger. But what if you copy larger into smaller? Well you simply do a bit copy and truncate the remaining. You can do some examples and verify that this works pretty well.

Now there is something interesting here, '=' is an overloaded operation. If you use '=' where LHS is a different format than the RHS, the '=' will try to convert the RHS into LHS format. For instance, if you assign a float '5' to int, semantically you are trying yo put value 5 into int. BUT the formats of int and float are very different, so the runtime actually takes the effort to convert float 5 into int 5 format and then store into int. This takes time. Everything must be considered while designing a speed sensitive system.

However you can fool the '=' by copying bit pattern of float to int. This can be done using pointers.

For example:

int i = 35;
float f = *(float*)&i;

This tells the compiler or runtime, that consider location of i as a float. So the compiler/runtime will simply copy the bit pattern from i to f.

Apparently, there are 2 things that '=' looks for - 
1. Whether the size of LHS and RHS is same or not
2. Whether the format of LHS and RHS is same or not

								LECTURE 3

							Big Endian vs Little Endian

Within a byte the order of the bits is the same for all computers.

Contrary to popular misconception, the Bit Patterns are NOT reversed. The Bytes are reversed. 

So if in Big Endian - 

Location 0 - 00010001
Location 1 - 11101110

In Little Endian it will be - 

Location 0 - 11101110
Location 1 - 00010001

Nice Explanation - https://stackoverflow.com/questions/12791864/c-program-to-check-little-vs-big-endian/12792301#12792301

								Interesting Teaser

struct fraction {
	int num;
	int denom;
}

fraction pi;
pi.num = 22;
pi.denom = 7;

If we do this - 

((fraction*)&(pi.denom))->num = 12;

What will happen?

Ans: pi.denom will now become 12. LOL.

									Array

Array 'x' is completely synonymous to '&x[0]'.
Similarly 'x + k' is completely synonymous to '&x[k]'. Btw 'k' is scaled to the size of the quantum of the Array.

Also '*x' is synonymous to 'x[0]'
And  '*(x + k)' = 'x[k]'

So when you say x[5] = 12, what you are essentially doing is '*(x + 5) = 12'

Difference between "strcpy" and "strdup" is that "strdup" allocates memory on Heap and then calls "strcpy" that just copies memory byte by byte.

So "strdup" = Malloc + "strcpy"

								LECTURE 4

"void*" has a major use when writing Generic C Functions. "void*" does NOT mean that it points to nothing, it basically means it is pointing to something whose type information it does not have.

So obviously you cannot Dereference a "void*" because how many bytes is the program supposed to look at and how is it supposed to interpret it? Well this issue explains what a Data Type is in technical terms - Data Type is the formal definition of how to interpret a given number of bytes. So Data Type is actually a Hash Key to a Value :D. Since "void*" points to a location but does not define what to do once we get to that location, we cannot DEREFERENCE it. Therefore dereferencing a "void*" makes no logical sense, only philosophical sense. Now this means that if some memory location is used by "void*" we are FREE to interpret that the way we want. Water takes the shape of the glass it is in. That is "void*" for you and the philosophical reasoning behind "void*". That is why "void*" is the most generic thing ever. Just like 0.

Just like "memcpy" is the generic version of "strcpy" because it does not take into consideration the '\0', therefore we need to provide the size of the total memory to be copied.

Let us write a Generic Swap:

void swap ( void* location1, void* location2, int size) 
{
	char buffer[size];
	memcpy(buffer, location1, size);
	memcpy(location1, location2, size);
	memcpy(location2, buffer);
}

//We are using 'int' in size and 'char' for temporary storage. So it appears that even to write the most generic functions, we need some convention. You cannot have a 100% Configurable system - Postulate. Wow!

Just FYI what is the difference between Generics and Templates (in C++). Well in Generics here, this code is compiled once and it is in memory. In Templates multiple copies of the code are generated based on the Data Types. So if you call Templates with 50 different Data Types you have generated 50 copies of the same code.

But it is VERY easy to go wrong with Generics in a large code base, because the compiler will compile anything. It does not coach or stop you from doing mistakes. There are no checks here. That is where Templates might help where it has checks etc.

Funny thing:

A wrong Swap can sometimes give you the right result depending on whether you are on Big Endian or Little Ending. For example thing what will happen if you wrote - 

int i = 44;
short j = 5;
swap(&x, &y, sizeof(short));

How will Big Endian differ from Little Endian here?

Well, let us say in Big Endian, the Byte Order is this - 

i => 00000000 00101100
j => 00000101

So Swap will do this:

i => 00000101 00101100
j => 00000000

i => 1324
j => 0

This is a problem. But if it is Little Endian - 

i => 00101100 00000000
j => 00000101

So Swap will be what you want

i => 00000101 00000000
j => 00101100

i => 5
j => 44

So even with wrong code, you got right results.

Let us write a Generic Compare Function:

void* lsearch (void* key, void* base_array_addr, int total_blocks, int block_size)
{

	for (int i = 0; i < total_blocks; i++ )
	{
		for (int j = 0; j < block_size; j++ )
		{
			if ( *((char*)key + j) != *((char*)base_array_addr + j + i*block_size) )
				break;

			if ( j == block_size - 1 )
				return (char*)base_array_addr + i*block_size; //Returns Address of the Element in the Array
		}
	}

return NULL;

}

								LECTURE 5

BTW the Compare Function can be even more generic, if you call the compare function itself.

The reason is you might want to compare things differently based on the Data Type. So its better to call the Compare function. In the above code you are essentially doing a bitwise compare using '==', what if you want to do compare differently depending on the Data Type? Right. Got it.

Sometimes when you have "char***" etc. A Data Type with multiple ***... It is better to think abstractly and think that in order to access the data at the location, we need to dereference that 3 times.

Note:

	int x = 5;
	printf("%p %p ", x, &x);

This will print the Hex of 5 and the address of x. Why? I mean it is understood that &x will print the memory location of x. But why does x print 5 in Hex? Well because %p seems to simply print the value in Hex. So the Value of 'x' is 5 and therefore it will print 0x05. I think this is not the proper use of %p.

What is the Difference between a Method and a Function?

A Function is an Object Oriented LESS Unit. It has no Object or Class declaration around it. A Method is something used in Classes and Object that has some information of the Object lying inside typically with the help of "this" pointer. So Methods have the address of the Object lying around as an invisible parameter called "this". A true Function has no idea about the kind of Object or Data Type. A Static Method in the Class will probably not have "this" pointer, so you can call it a Function.

								LECTURE 6

Explain Extern? (Ans. from StackOverFlow)

        "extern" changes the linkage. With the keyword, the function / variable is assumed to be available somewhere else and the resolving is deferred to the linker.
	There's a difference between "extern" on functions and on variables: on variables it doesn't instantiate the variable itself, i.e. doesn't allocate any memory. This needs to be done somewhere else. Thus it's important if you want to import the variable from somewhere else. For functions, this only tells the compiler that linkage is extern. As this is the default (you use the keyword "static" to indicate that a function is not bound using extern linkage) you don't need to use it explicitly."

	Moreover, by using the extern mechanism you tell the compiler: I declared something that’s defined elsewhere, you will find at link time. It’s problematic for type verification as the linker works simply with symbol names and addresses. All type related information is forgotten at this time.

Explanation on Cisco Wiki - 

	We have a lot of "extern" declarations in our C source files. Most if not all of them are subverting the compiler's type checking in that they provide access to an external data object without verifying that the stated type of the object is correct. For example, if you have
        	
		int foo_var;

	in 'foo.c', and you want to reference "foo_var" in 'bar.c', you could put
        
		extern int foo_var;

	in 'bar.c'.  Doing so doesn't allow any type checking against the actual definition, so if you later change the definition in 'foo.c' to
        
		unsigned int foo_var;
	
	'bar.c' will have an "extern" for the wrong type, but it will still compile without warning.

	The right way to reference external data is through a header file that is referenced both places.  For example, 'foo.h' would have
        
		extern int foo_var;

	and would be included in both 'foo.c' and 'bar.c'.  Then if you change 'foo.c' so that "foo_var" is an unsigned int, the compiler will notice that the declaration in 'foo.h' conflict with the definition in 'foo.c' and emit an error message. Fixing the declaration in 'foo.h' allows 'foo.c' to compile and makes the updated type visible in 'bar.c'.

When to use Double Pointers OR Pointers as function parameters?

	A Server function that accepts a Pointer will always be something like this 'void func(ptr_type* ptr)', but it could also be 'void func(ptr_type** ptr)' etc. Now what is the difference between both? Imagine you are a Client, and you have a pointer 'ptr_st' pointing to a structure. The 'ptr_st' is of type 'ptr_type'. Now if you want the structure to be modified, you use the first function, BUT if you want the pointer itself to point to something else, you use the second function. So, anything 'X' that needs to be modified, needs to be passed as '&X' to a Server function. Now X could be of ANY TYPE. Applying this rule here, if we want the structure to be modified, we pass &structure which is equal to 'ptr_st' so we call

func(ptr_st);

but if we want, the pointer itself to be modified, we pass &ptr_st, so we call

func(&ptr_st);

Because what the server function will do, it create a NEW variable, called 'ptr'. And if you want 'ptr_st' to be modified, BUT you call

func(ptr_st); then a new variable 'ptr' will store the value of 'ptr_st' and hence will be pointing to the struture.

NOTE: If you want a function to modify something X, X could be ANYTHING, the function somehow NEEDS to know the address of X.

-
